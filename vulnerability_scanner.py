#!/usr/bin/env python3
"""
Vulnerability Scanner - Scans localhost for vulnerable HTTP and SSH services
Code generated with assistance from Claude (Anthropic) - October 2025
Uses nmap (python-nmap library) for port scanning as specified in assignment
"""

import nmap
import paramiko
import requests
from requests.auth import HTTPBasicAuth
import sys
import warnings
import logging
import socket

# Suppress warnings
warnings.filterwarnings('ignore')
logging.getLogger("paramiko").setLevel(logging.CRITICAL)
requests.packages.urllib3.disable_warnings()

def scan_ports(verbose=False):
    """Scan localhost for open TCP ports below 9000 using nmap"""
    if verbose:
        print("[*] Scanning ports on 127.0.0.1 with nmap...", file=sys.stderr)
    
    nm = nmap.PortScanner()
    try:
        # Scan ports 1-8999, use -Pn to skip host discovery
        nm.scan('127.0.0.1', '1-8999', arguments='-Pn')
    except Exception as e:
        if verbose:
            print(f"[!] Error scanning: {e}", file=sys.stderr)
        return []
    
    open_ports = []
    try:
        if '127.0.0.1' in nm.all_hosts():
            for proto in nm['127.0.0.1'].all_protocols():
                ports = nm['127.0.0.1'][proto].keys()
                for port in ports:
                    if nm['127.0.0.1'][proto][port]['state'] == 'open':
                        open_ports.append(port)
    except Exception as e:
        if verbose:
            print(f"[!] Error processing scan results: {e}", file=sys.stderr)
    
    return sorted(open_ports)

def classify_port(port, verbose=False):
    """Lightweight protocol classification for an open port.
    - Detects SSH by banner (SSH-2.0-...)
    - Detects HTTP by sending a minimal HEAD and looking for HTTP/ in response
    Returns: 'ssh' | 'http' | 'unknown'
    """
    try:
        with socket.create_connection(("127.0.0.1", port), timeout=0.5) as s:
            s.settimeout(0.5)
            # Try to read an immediate banner (typical for SSH)
            try:
                data = s.recv(64)
                if data.startswith(b"SSH-"):
                    if verbose:
                        print(f"[*] Detected SSH banner on port {port}", file=sys.stderr)
                    return "ssh"
            except socket.timeout:
                pass

            # Try a very small HTTP probe
            try:
                s.sendall(b"HEAD / HTTP/1.0\r\nHost: 127.0.0.1\r\n\r\n")
                data = s.recv(64)
                if b"HTTP/" in data:
                    if verbose:
                        print(f"[*] Detected HTTP on port {port}", file=sys.stderr)
                    return "http"
            except Exception:
                pass
    except Exception:
        pass
    return "unknown"

def try_http(port, username, password, verbose=False):
    """Attempt HTTP basic authentication"""
    if verbose:
        print(f"[*] Trying HTTP on port {port} with {username}:{password}", file=sys.stderr)
    
    try:
        response = requests.get(
            f'http://127.0.0.1:{port}',
            auth=HTTPBasicAuth(username, password),
            timeout=5
        )
        if response.status_code == 200:
            output = response.text.strip()
            # Get just the first word/line of output
            if output:
                # Split by whitespace and take first word, or first 50 chars
                first_word = output.split()[0] if output.split() else output[:50]
                print(f"http://{username}:{password}@127.0.0.1:{port} {first_word}")
            else:
                print(f"http://{username}:{password}@127.0.0.1:{port} success")
            return True
    except Exception as e:
        if verbose:
            print(f"[!] HTTP error: {type(e).__name__}", file=sys.stderr)
    
    return False

def try_ssh(port, username, password, verbose=False):
    """Attempt SSH password authentication"""
    if verbose:
        print(f"[*] Trying SSH on port {port} with {username}:{password}", file=sys.stderr)
    
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        client.connect(
            '127.0.0.1',
            port=port,
            username=username,
            password=password,
            timeout=5,
            allow_agent=False,
            look_for_keys=False,
            banner_timeout=10,
            auth_timeout=10
        )
        
        # Try to get server output - check if there's a welcome banner or message
        output = "success"
        
        try:
            # Try to execute a simple command
            stdin, stdout, stderr = client.exec_command('echo', timeout=2)
            cmd_output = stdout.read().decode('utf-8').strip()
            if cmd_output:
                output = cmd_output
        except:
            pass
        
        # If still no output, try reading the channel directly
        if output == "success":
            try:
                transport = client.get_transport()
                if transport and transport.is_authenticated():
                    channel = transport.open_session()
                    channel.settimeout(1)
                    channel.send('\n')
                    received = channel.recv(1024).decode('utf-8').strip()
                    if received:
                        output = received.split()[0] if received.split() else received
                    channel.close()
            except:
                pass
            
        print(f"ssh://{username}:{password}@127.0.0.1:{port} {output}")
        client.close()
        return True
        
    except paramiko.AuthenticationException:
        if verbose:
            print(f"[!] SSH auth failed for {username}", file=sys.stderr)
    except Exception as e:
        if verbose:
            print(f"[!] SSH error: {type(e).__name__}", file=sys.stderr)
    finally:
        try:
            client.close()
        except:
            pass
    
    return False

def main():
    verbose = '-v' in sys.argv or '--verbose' in sys.argv
    
    credentials = {
        'admin': 'admin',
        'root': 'abc123',
        'skroob': '12345'
    }
    
    # Scan for open ports using nmap
    open_ports = scan_ports(verbose)
    
    if verbose:
        print(f"[*] Found open ports: {open_ports}", file=sys.stderr)
    
    # Classify each port and try appropriate protocol to avoid cross-noise
    for port in open_ports:
        kind = classify_port(port, verbose)
        if kind == "http":
            for username, password in credentials.items():
                try_http(port, username, password, verbose)
        elif kind == "ssh":
            for username, password in credentials.items():
                try_ssh(port, username, password, verbose)
        else:
            if verbose:
                print(f"[-] Port {port} unclassified; skipping to reduce noise", file=sys.stderr)

if __name__ == '__main__':
    main()
